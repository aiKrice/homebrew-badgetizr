#!/bin/bash

# Detect base path for all files (works in dev and Homebrew)
detect_base_path() {
    if [[ -f "$(dirname "$0")/utils.sh" ]]; then
        dirname "$0"
    else
        echo "$(dirname "$0")/../libexec"
    fi
}

# load extra files
BASE_PATH=$(detect_base_path)
source "${BASE_PATH}/utils.sh"
source "${BASE_PATH}/providers/provider_utils.sh"

config_file=".badgetizr.yml"

while getopts "c:hv-:" opt; do
    case ${opt} in
        c)
            config_file="${OPTARG}"
            ;;
        h)
            show_help
            exit 0
            ;;
        v)
            # shellcheck disable=SC2154  # BADGETIZR_VERSION is defined in utils.sh
            echo "${BADGETIZR_VERSION}"
            exit 0
            ;;
        -)
            case "${OPTARG}" in
                configuration=*)
                    config_file="${OPTARG#*=}"
                    ;;
                configuration)
                    config_file="${!OPTIND}"; OPTIND=$(( OPTIND + 1 ))
                    ;;
                pr-build-number=*)
                    ci_badge_build_number="${OPTARG#*=}"
                    ;;
                pr-build-number)
                    ci_badge_build_number="${!OPTIND}"; OPTIND=$(( OPTIND + 1 ))
                    ;;
                pr-build-url=*)
                    ci_badge_build_url="${OPTARG#*=}"
                    ;;
                pr-build-url)
                    ci_badge_build_url="${!OPTIND}"; OPTIND=$(( OPTIND + 1 ))
                    ;;
                pr-destination-branch=*)
                    ci_badge_destination_branch="${OPTARG#*=}"
                    ;;
                pr-destination-branch)
                    ci_badge_destination_branch="${!OPTIND}"; OPTIND=$(( OPTIND + 1 ))
                    ;;
                pr-id=*)
                    ci_badge_pull_request_id="${OPTARG#*=}"
                    ;;
                pr-id)
                    ci_badge_pull_request_id="${!OPTIND}"; OPTIND=$(( OPTIND + 1 ))
                    ;;
                provider=*)
                    forced_provider="${OPTARG#*=}"
                    ;;
                provider)
                    forced_provider="${!OPTIND}"; OPTIND=$(( OPTIND + 1 ))
                    ;;
                ci-status=*)
                    ci_status_badge_status="${OPTARG#*=}"
                    ;;
                ci-status)
                    ci_status_badge_status="${!OPTIND}"; OPTIND=$(( OPTIND + 1 ))
                    ;;
                ci-text=*)
                    ci_status_badge_text="${OPTARG#*=}"
                    ;;
                ci-text)
                    ci_status_badge_text="${!OPTIND}"; OPTIND=$(( OPTIND + 1 ))
                    ;;
                version)
                    echo "${BADGETIZR_VERSION}"
                    exit 0
                    ;;
                help)
                    show_help
                    exit 0
                    ;;
                *)
                    echo "Invalid option --${OPTARG}" >&2
                    echo "Use --help for more information." >&2
                    exit 1
                    ;;
            esac
            ;;

        \?)
            echo "Invalid option: -${OPTARG}" >&2
            echo "Use --help for more information." >&2
            exit 1
            ;;
        *)
            echo "Unexpected option: -${opt}" >&2
            echo "Use --help for more information." >&2
            exit 1
            ;;
    esac
done

# Determine provider (forced or auto-detected)
if [[ -n "${forced_provider}" ]]; then
    PROVIDER="${forced_provider}"
    echo "üîß Forced provider: ${PROVIDER}"
else
    PROVIDER=$(detect_provider)
    echo "üîç Detected provider: ${PROVIDER}"
fi

# Check mandatory parameter first (before authentication)
if [[ -z "${ci_badge_pull_request_id}" ]]; then
    echo "üî¥ Error: --pr-id is mandatory." >&2
    show_help
    exit 1
fi

# Load the provider
if [[ "${PROVIDER}" != "github" && "${PROVIDER}" != "gitlab" ]]; then
    echo "‚ùå Error: Unsupported provider '${PROVIDER}'. Supported: github, gitlab"
    exit 1
fi

# Check if required CLI is installed
if ! check_provider_cli "${PROVIDER}"; then
    exit 1
fi

load_provider "${PROVIDER}"

# Test provider authentication
if ! test_provider_auth; then
    exit 1
fi

if [[ -f "${config_file}" && -s "${config_file}" ]]; then
    wip_badge_enabled=$(yq e '.badge_wip.enabled // "true"' "${config_file}")
    wip_badge_label=$(yq e '.badge_wip.settings.label // "Work in Progress"' "${config_file}")
    wip_badge_color=$(yq e '.badge_wip.settings.color // "yellow"' "${config_file}")
    wip_badge_logo=$(yq e '.badge_wip.settings.logo // "vlcmediaplayer"' "${config_file}")
    wip_badge_labelized=$(yq e '.badge_wip.settings.labelized // ""' "${config_file}")

    hotfix_badge_enabled=$(yq e '.badge_hotfix.enabled // "false"' "${config_file}")
    hotfix_badge_color=$(yq e '.badge_hotfix.settings.color // "red"' "${config_file}")
    hotfix_badge_text_color=$(yq e '.badge_hotfix.settings.text_color // "white"' "${config_file}")
    hotfix_badge_label=$(yq e '.badge_hotfix.settings.label // "HOTFIX"' "${config_file}")
    hotfix_badge_labelized=$(yq e '.badge_hotfix.settings.labelized // ""' "${config_file}")

    branch_badge_enabled=$(yq e '.badge_base_branch.enabled // "false"' "${config_file}")
    branch_badge_base_branch=$(yq e '.badge_base_branch.settings.base_branch // "develop"' "${config_file}")
    branch_badge_color=$(yq e '.badge_base_branch.settings.color // "orange"' "${config_file}")
    branch_badge_label=$(yq e '.badge_base_branch.settings.label // "Target branch"' "${config_file}")

    ci_badge_enabled=$(yq e '.badge_ci.enabled // "false"' "${config_file}")
    ci_badge_label=$(yq e '.badge_ci.settings.label // "CI"' "${config_file}")
    ci_badge_logo=$(yq e '.badge_ci.settings.logo // "github"' "${config_file}")
    ci_badge_color=$(yq e '.badge_ci.settings.color // "purple"' "${config_file}")
    ci_badge_label_color=$(yq e '.badge_ci.settings.label_color // "black"' "${config_file}")

    ticket_badge_enabled=$(yq e '.badge_ticket.enabled // "false"' "${config_file}")
    ticket_badge_pattern=$(yq e '.badge_ticket.settings.sed_pattern // ".*\\(([^)]+)\\).*"' "${config_file}")
    ticket_badge_url=$(yq e '.badge_ticket.settings.url // "https://yourproject.atlassian.net/browse/"' "${config_file}")
    ticket_badge_color=$(yq e '.badge_ticket.settings.color // "blue"' "${config_file}")
    ticket_badge_label=$(yq e '.badge_ticket.settings.label // "Jira"' "${config_file}")
    ticket_badge_logo=$(yq e '.badge_ticket.settings.logo // "jirasoftware"' "${config_file}")

    dynamic_badge_enabled=$(yq e '.badge_dynamic.enabled // "false"' "${config_file}")

    ready_for_approval_badge_enabled=$(yq e '.badge_ready_for_approval.enabled // "false"' "${config_file}")
    ready_for_approval_badge_color=$(yq e '.badge_ready_for_approval.settings.color // "darkgreen"' "${config_file}")
    ready_for_approval_badge_label=$(yq e '.badge_ready_for_approval.settings.label // "Ready"' "${config_file}")
    ready_for_approval_badge_logo=$(yq e '.badge_ready_for_approval.settings.logo // "checkmark"' "${config_file}")
    ready_for_approval_badge_labelized=$(yq e '.badge_ready_for_approval.settings.labelized // ""' "${config_file}")

else
    echo "üîµ ${config_file} not found. Using default values."
    wip_badge_enabled="true"
    wip_badge_label="Work in Progress"
    wip_badge_color="yellow"
    wip_badge_logo="vlcmediaplayer"

    hotfix_badge_enabled="false"
    hotfix_badge_color="red"
    hotfix_badge_text_color="white"
    hotfix_badge_label="HOTFIX"

    branch_badge_enabled="true"
    branch_badge_base_branch="develop"
    branch_badge_color="orange"
    branch_badge_label="Target branch"

    ci_badge_enabled="false"
    ticket_badge_enabled="false"
    dynamic_badge_enabled="false"
    ready_for_approval_badge_enabled="false"
fi

pull_request_title=$(get_pr_info "${ci_badge_pull_request_id}" "title")
pull_request_body=$(get_pr_info "${ci_badge_pull_request_id}" "body")
destination_branch=$(get_destination_branch "${ci_badge_pull_request_id}")

# Extract current badges from the pull request body
pull_request_body=$(echo "${pull_request_body}" | awk '/<!--begin:badgetizr-->/ {flag=1; next} /<!--end:badgetizr-->/ {flag=0; next} !flag' | tr -d '\r')          

all_badges=

#Ticket Badge
if [[ "${ticket_badge_enabled}" = "true" ]]; then
    ticket_id=$(echo "${pull_request_title}" | sed -n -E "s/${ticket_badge_pattern}/\1/p")
    if [[ -z "${ticket_id}" ]]; then
        echo "üü† No ticket id identified in the PR title. Maybe your pattern is not correct."
    else
        echo "üü° Ticket id identified is -> ${ticket_id}"
        # shellcheck disable=SC2059  # ticket_badge_url contains %s placeholder from config
        ticket_badge_url_for_badge=$(printf "${ticket_badge_url}" "${ticket_id}")
        ticket_id_for_badge=$(echo "${ticket_id}" | sed -E 's/ /_/g; s/-/--/g') 
        ticket_badge="[![Static Badge](https://img.shields.io/badge/${ticket_badge_label}-${ticket_id_for_badge}-${ticket_badge_color}?logo=${ticket_badge_logo}&color=${ticket_badge_color}&labelColor=grey)](${ticket_badge_url_for_badge})"
        all_badges=${all_badges}${ticket_badge}
    fi
fi


# Target Branch Badge 
if [[ "${branch_badge_enabled}" = "true" ]]; then
    if [[ -z "${ci_badge_destination_branch}" ]]; then
        echo "üî¥ Error: --pr-destination-branch is mandatory when branch badge is enabled. Use -h for help." >&2
        exit 1
    fi

    branch_badge_label_for_badge=$(echo "${branch_badge_label}" | sed -E 's/ /_/g; s/-/--/g')
    if [[ "${ci_badge_destination_branch}" != "${branch_badge_base_branch}" ]];then
        branch_badge="![Static Badge](https://img.shields.io/badge/${branch_badge_label_for_badge}-${ci_badge_destination_branch}-${branch_badge_color}?labelColor=grey&color=${branch_badge_color})"
        all_badges="${all_badges} ${branch_badge}"
    fi
fi

# Hotfix Badge
if [[ "${hotfix_badge_enabled}" = "true" ]]; then
    if [[ "${destination_branch}" == "main" || "${destination_branch}" == "master" ]]; then
        hotfix_badge="![Static Badge](https://img.shields.io/badge/${hotfix_badge_label}-${hotfix_badge_color}?logoColor=${hotfix_badge_text_color}&color=${hotfix_badge_color})"
        all_badges="${all_badges} ${hotfix_badge}"

        # Add pr/mr label if labelized is set
        if [[ -n "${hotfix_badge_labelized}" && "${hotfix_badge_labelized}" != "null" ]]; then
            if ! add_pr_label "${ci_badge_pull_request_id}" "${hotfix_badge_labelized}"; then
                # Create hotfix label with red color (non-customizable)
                if create_pr_label "${hotfix_badge_labelized}" "d73a49" "Auto-created by Badgetizr for hotfix detection"; then
                    add_pr_label "${ci_badge_pull_request_id}" "${hotfix_badge_labelized}"
                fi
            fi
        fi
    else
        # PR is not targeting main/master, remove label if configured
        if [[ -n "${hotfix_badge_labelized}" && "${hotfix_badge_labelized}" != "null" ]]; then
            remove_pr_label "${ci_badge_pull_request_id}" "${hotfix_badge_labelized}"
        fi
    fi
else
    # Hotfix badge disabled, remove label if configured
    if [[ -n "${hotfix_badge_labelized}" && "${hotfix_badge_labelized}" != "null" ]]; then
        remove_pr_label "${ci_badge_pull_request_id}" "${hotfix_badge_labelized}"
    fi
fi

# Wip Badge
if [[ "${wip_badge_enabled}" = "true" ]]; then
    if [[ "${pull_request_title}" =~ [Ww][Ii][Pp] ]]; then
        wip_badge="![Static Badge](https://img.shields.io/badge/${wip_badge_label}-${wip_badge_color}?logo=${wip_badge_logo}&logoColor=white)"
        all_badges="${all_badges} ${wip_badge}"

        # Add pr/mr label if labelized is set
        if [[ -n "${wip_badge_labelized}" && "${wip_badge_labelized}" != "null" ]]; then
            if ! add_pr_label "${ci_badge_pull_request_id}" "${wip_badge_labelized}"; then
                # Label doesn't exist, create it with appropriate color
                hex_color=""
                case "${wip_badge_color}" in
                    "yellow") hex_color="fbca04" ;;
                    "orange") hex_color="d93f0b" ;;
                    "red") hex_color="d73a49" ;;
                    "green"|"forestgreen") hex_color="28a745" ;;
                    "blue") hex_color="0366d6" ;;
                    "purple") hex_color="6f42c1" ;;
                    "grey"|"gray") hex_color="586069" ;;
                    "black") hex_color="24292e" ;;
                    *) hex_color="fbca04" ;;  # Default to yellow for WIP
                esac

                if create_pr_label "${wip_badge_labelized}" "${hex_color}" "Auto-created by Badgetizr"; then
                    add_pr_label "${ci_badge_pull_request_id}" "${wip_badge_labelized}"
                fi
            fi
        fi
    else
        # PR is no longer WIP, remove label if configured
        if [[ -n "${wip_badge_labelized}" && "${wip_badge_labelized}" != "null" ]]; then
            remove_pr_label "${ci_badge_pull_request_id}" "${wip_badge_labelized}"
        fi
    fi
else
    # WIP badge disabled, remove label if configured
    if [[ -n "${wip_badge_labelized}" && "${wip_badge_labelized}" != "null" ]]; then
        remove_pr_label "${ci_badge_pull_request_id}" "${wip_badge_labelized}"
    fi
fi

# Dynamic Badge
if [[ "${dynamic_badge_enabled}" = "true" ]]; then
    badge_count=$(yq '.badge_dynamic.settings.patterns | length' "${config_file}")
    for ((i=0; i<badge_count; i++)); do
        label=$(yq ".badge_dynamic.settings.patterns[${i}].label // \"Badge_$1\"" "${config_file}")
        pattern=$(yq ".badge_dynamic.settings.patterns[${i}].sed_pattern // \"no_pattern\"" "${config_file}")

        match=$(echo "${pull_request_body}" | sed -n -E "s/${pattern}/\1/p")
        if [[ -z "${match}" ]]; then
            echo "üîµ Match=${match} is empty for badge label: ${label} at position[${i}]. Check your regex: ${pattern} against your PR. The regexp must contain a group (*.)"
            continue
        fi

        default_label=$(echo "${label}" | sed -E 's/ /_/g; s/-/--/g')
        override_label=$(jq -rn --arg s "${label}" '${s} | @uri')
        value=$(yq ".badge_dynamic.settings.patterns[${i}].value // \"default\"" "${config_file}" | sed -E 's/ /_/g; s/-/--/g')
        color=$(yq ".badge_dynamic.settings.patterns[${i}].color // \"orange\"" "${config_file}")
        
        dynamic_badge="![Static Badge](https://img.shields.io/badge/${default_label}-${value}-grey?label=${override_label}&labelColor=grey&color=${color})"
        all_badges="${all_badges} ${dynamic_badge}"
    done
fi

# Ready for Approval Badge
if [[ "${ready_for_approval_badge_enabled}" = "true" ]]; then
    # Count unchecked checkboxes in PR body
    unchecked_count=$(printf "%s\n" "${pull_request_body}" | grep -c "\- \[ \]" 2>/dev/null || echo "0")
    unchecked_count=$(echo "${unchecked_count}" | tr -d '[:space:]')

    if [[ "${unchecked_count}" -gt 0 ]]; then
        echo "üî≤ Found ${unchecked_count} unchecked checkbox(es), PR not ready for approval"

        # Remove ready for approval label if configured
        if [[ -n "${ready_for_approval_badge_labelized}" && "${ready_for_approval_badge_labelized}" != "null" ]]; then
            remove_pr_label "${ci_badge_pull_request_id}" "${ready_for_approval_badge_labelized}"
        fi
    else
        echo "‚úÖ All checkboxes are checked, PR ready for approval"

        # Create ready for approval badge
        ready_for_approval_badge="![Static Badge](https://img.shields.io/badge/${ready_for_approval_badge_label}-${ready_for_approval_badge_color}?logo=${ready_for_approval_badge_logo}&logoColor=white&color=${ready_for_approval_badge_color})"
        all_badges="${all_badges} ${ready_for_approval_badge}"

        # Add ready for approval label if configured
        if [[ -n "${ready_for_approval_badge_labelized}" && "${ready_for_approval_badge_labelized}" != "null" ]]; then
            if ! add_pr_label "${ci_badge_pull_request_id}" "${ready_for_approval_badge_labelized}"; then
                # Label doesn't exist, create it with green color
                if create_pr_label "${ready_for_approval_badge_labelized}" "28a745" "Auto-created by Badgetizr for approval tracking"; then
                    add_pr_label "${ci_badge_pull_request_id}" "${ready_for_approval_badge_labelized}"
                fi
            fi
        fi
    fi
else
    # Ready for approval badge disabled, remove label if configured
    if [[ -n "${ready_for_approval_badge_labelized}" && "${ready_for_approval_badge_labelized}" != "null" ]]; then
        remove_pr_label "${ci_badge_pull_request_id}" "${ready_for_approval_badge_labelized}"
    fi
fi

# CI Badge (unified with status support)
if [[ "${ci_badge_enabled}" = "true" ]]; then
    # pr-build-url is always mandatory for CI badge
    if [[ -z "${ci_badge_build_url}" ]]; then
        echo "üî¥ Error: --pr-build-url is mandatory when CI badge is enabled." >&2
        exit 1
    fi

    # If ci-status is provided, we're in status mode
    if [[ -n "${ci_status_badge_status}" ]]; then
        # Validate status value (only 4 allowed)
        case "${ci_status_badge_status}" in
            "started")
                ci_color="yellow"
                ;;
            "passed")
                ci_color="darkgreen"
                ;;
            "warning")
                ci_color="orange"
                ;;
            "failed")
                ci_color="red"
                ;;
            *)
                echo "‚ùå Error: Invalid CI status '${ci_status_badge_status}'. Allowed: started, passed, warning, failed" >&2
                exit 1
                ;;
        esac

        # Determine badge text based on status
        if [[ "${ci_status_badge_status}" == "started" || "${ci_status_badge_status}" == "warning" ]]; then
            # For intermediate statuses, use custom text if provided, otherwise use status
            if [[ -n "${ci_status_badge_text}" ]]; then
                ci_text="${ci_status_badge_text}"
            else
                ci_text="${ci_status_badge_status}"
            fi
        else
            # For passed/failed, use build number if available, otherwise custom text, otherwise status
            if [[ -n "${ci_badge_build_number}" ]]; then
                ci_text="${ci_badge_build_number}"
            elif [[ -n "${ci_status_badge_text}" ]]; then
                ci_text="${ci_status_badge_text}"
            else
                ci_text="${ci_status_badge_status}"
            fi
        fi

        echo "üîÑ Updating CI badge: ${ci_status_badge_status} (${ci_text})"
    else
        # Legacy mode: no status provided, use build number (backward compatibility)
        if [[ -z "${ci_badge_build_number}" ]]; then
            echo "üî¥ Error: --pr-build-number is mandatory when no --ci-status is provided." >&2
            exit 1
        fi
        ci_color="${ci_badge_color}"
        ci_text="${ci_badge_build_number}"
        echo "üîÑ Creating CI badge: build ${ci_text}"
    fi

    # Escape text and label for URL
    ci_text_escaped=$(echo "${ci_text}" | sed -E 's/ /_/g; s/-/--/g')
    ci_label_escaped=$(echo "${ci_badge_label}" | sed -E 's/ /_/g; s/-/--/g')

    # Create unified CI badge (always clickable)
    ci_badge="[![Static Badge](https://img.shields.io/badge/${ci_text_escaped}-ignored?label=${ci_label_escaped}&logo=${ci_badge_logo}&logoColor=white&labelColor=${ci_badge_label_color}&color=${ci_color})](${ci_badge_build_url})"
    all_badges="${all_badges} ${ci_badge}"

    echo "‚úÖ CI badge added to badges collection"
fi

# Add delimiter for next replacement
all_badges=$(printf "<!--begin:badgetizr--> \n%s\n<!--end:badgetizr-->" "${all_badges}")

# Build new body
new_pull_request_body=$(printf "%s\n%s" "${all_badges}" "${pull_request_body}")

# Update PR description
update_pr_description "${ci_badge_pull_request_id}" "${new_pull_request_body}"
